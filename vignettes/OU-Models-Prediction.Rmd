---
title: "OU-Models-Prediction"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{OU-Models-Prediction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# OU Models with Prediction
This vignette walks you through the basic steps of running an analysis in Blouch including prediction of unknown/fossil values.

## Setup

Here we load the R packages used to setup the data for blouch, make figures post-analysis, etc.
```{r Setup}
rm(list=ls())
library(devtools)
#devtools::install_github("Mark-Grabowski/blouch")
#library(blouch)

#devtools::install_github("Mark-Grabowski/blouch"
#                         ,ref="master"
#                         ,auth_token = "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"
#                         )
library(blouch)
load_all()
# Load necessary packages
library(ape)
library(slouch)
library(rstan)
library(treeplyr)
library(ggplot2)
library(bridgesampling)

#For execution on a local, multicore CPU with excess RAM we recommend calling
#options(mc.cores = parallel::detectCores())
options(mc.cores = 2)
rstan_options(auto_write = TRUE)

#remotes::install_github("stan-dev/rstan", ref = "develop", subdir = "rstan/rstan")

```

## Scale Tree
For the purposes of illustrating the software, we will use a dataset of ruminant brain and body sizes bundled with the Slouch package (Kopperud et al. 2020) and a corresponding phylogenetic tree (ToljagiÄ‡ et al. 2017). First, we will organize the brain and body data.

```{r}
## Load the phylogenetic tree with annotation data
data(artiodactyla)
phy <- artiodactyla

## Load the neocortex dataset
data(neocortex)

## Plot the tree
plot(ladderize(phy), cex = 0.6)
```
## Data Prep
We will use the treeplyr function make.treedata to combine the data and tree based on the "species" column, which has the taxa names. See https://github.com/uyedaj/treeplyr for more on this package.Then we will finlter the data so only individuals with both brain and body size, as well as the variance in brain and body size are included. Variance in these traits is considered measurement error, estimation error in species averages. 


```{r}
ruminant.trdata <- make.treedata(phy, neocortex,name_column="species")

ruminant.trdata<-filter(ruminant.trdata,!(is.na(brain_mass_g_log_mean)) & !(is.na(body_mass_g_log_mean)))
ruminant.trdata<-filter(ruminant.trdata,!(is.na(brain_se_squared)) & !(is.na(body_se_squared)))

ruminant.trdata #Full dataset

```

## Classical Regression
Here we will assign one taxa as the fossil species to be predicted, and use Classical Regression to predict an unknown value based on the combination of phylogeny and allometry. Here we are regression Y - brain size on X body size, and then predicting a fossil X (body size) based on its Y (brain size). Finally we mean scale the X data (here body mass) so that the average across species is 0.

```{r}
ruminant.trdata$dat$Status<-"Extant" #Label all species as extant
ruminant.trdata$dat$Status[1]<-"Extinct" #Make one extinct
n.fos<-1

#Classical Regression - Predicting X using regression of Y on X
ruminant.trdata$dat$body_mass_g_log_mean[1]<-0 #Assign this species fake body mass
ruminant.trdata$dat$body_se_squared[1]<-0 #And ME

ruminant.extant.trdata<-filter(ruminant.trdata, (Status == "Extant")) #Only non-fossil species

#Mean Standardized based on whether fossil is included in dataset

#Classical regression - predicting brain size - X
ruminant.trdata$dat$bodycentered<-ruminant.trdata$dat$body_mass_g_log_mean-mean(ruminant.trdata$dat$body_mass_g_log_mean[-n.fos])
ruminant.extant.trdata$dat$bodycentered<-ruminant.extant.trdata$dat$body_mass_g_log_mean-mean(ruminant.extant.trdata$dat$body_mass_g_log_mean)

```
## Rescale Tree
Next, we rescale Tree to Height = 1
```{r}
l.tree<-max(branching.times(ruminant.trdata$phy))
ruminant.trdata$phy$edge.length<-ruminant.trdata$phy$edge.length/l.tree ## rescale tree to height 1
max(branching.times(ruminant.trdata$phy))

l.tree<-max(branching.times(ruminant.extant.trdata$phy))
ruminant.extant.trdata$phy$edge.length<-ruminant.extant.trdata$phy$edge.length/l.tree ## rescale tree to height 1
max(branching.times(ruminant.extant.trdata$phy))

```

## Running Blouch Data Setup Function - 1st trait is adapting to 2
Here we are finally setting up our dataset to run in Blouch, using the blouchOUPredict.setup.v1() function. This function takes out data formatted by treeplyr, and the names of our traits of interest in the order shown. The list produced by this function has data formatted to run both the direct effect (constraint) models and adaptative models. See Grabowski et al. (2016) for more on both of these models.
```{r}
#names.traits<-c("brain_mass_g_log_mean","bodycentered","NA","NA") #With ME
names.traits<-c("brain_mass_g_log_mean","bodycentered","brain_se_squared","body_se_squared") #With ME

#Data must be logged before entry into blouch.setup
#names.traits = c(response, predictor, me.response, me.predictor) - classical = 0 for inverse regression
stan_data<-blouchOUPredict.setup.v1(ruminant.extant.trdata,ruminant.trdata,names.traits,classical=1)

stan_constraint_data<-stan_data[[1]]
stan_adaptive_data<-stan_data[[2]]

```

## Explore Priors: Slope and intercept
Priors must be set manually in the Stan Blouch code (e.g. blouchOUPredict_v1.stan), but we use the same priors for this analysis as in the OU-Models vignette. Go back and look at that vignette if you need to explore the effect of your priors - do not use the default values.

## Direct EFfect Model for Prediction
Now that we have formatted our data and supplied reasonable priors for the various distributions, we can now run Blouch.

Blouch implements the model of constrained evolution (Hansen & Bartoszek, 2012) known as the direct effect model, previously implemented in Grabowski et al. (2016), which can be used to test for allometric constraints. We will be using this model to predict unknown values as assuming an allometric relationship may be more valid in prediction than an adaptive relationship.

Here we run this model using 2 chains and 4000 iterations per chain. This code follows standard Stan/Rstan code.

```{r}
fit.fos.direct<- rstan::sampling(stanmodels$blouchOUPredict_v1,data = stan_constraint_data,chains = 2,iter = 4000,control=list(adapt_delta=0.95),save_warmup=FALSE)

```

Stan prints out a lot of info, so lets just look at the parameter estimates here and store the most important stuff for later.

```{r}
print(fit.fos.direct,pars = c("a","hl","alpha","beta","r_squared","sigma2_y","RMSE","RMSE_mu","X_pred_fos_means"))

posterior.fit.fos.direct <- rstan::extract(fit.fos.direct)

```

Blouch follows the same format of parameter estimate presentation as Slouch - see Hansen et al. (2008), Grabowski et al. (2016), and Kopperud et al. (2020) for more explanation.

## Trace and Density Plots for estimated parameters
We can look at how our procedures using the standard trace and density plots from Rstan 

```{r}
par(mfrow = c(1,3))
  
traceplot(fit.fos.direct,c("a","hl","alpha","beta","vy","sigma2_y"))
stan_dens(fit.fos.direct,c("a","hl","alpha","beta","vy","sigma2_y"))
#3 X 8
```

## Plots

Let's make some plots of our results

```{r}
library(ggsci)
library(ggplot2)
library(plotly)

```

## Data Setup for Plots
```{r}
old.par <- par(mar = c(0, 0, 0, 0))
par(old.par)

fos.index<-which(ruminant.trdata$dat$Status=="Extinct")
print(paste("Fossil Species #",fos.index))
extant.index<-which(ruminant.trdata$dat$Status=="Extant")

body.predictions<-apply(posterior.fit.fos.direct$X_pred_fos_means,2,mean)
body.predictions.extant<-apply(posterior.fit.fos.direct$X_pred_extant_means,2,mean)

extant.data<-data.frame(Genus_Species = ruminant.trdata$phy$tip.label[-fos.index],log_brain = ruminant.trdata$dat$brain_mass_g_log_mean[-fos.index],log_body_pred = body.predictions.extant,log_body = ruminant.trdata$dat$bodycentered[-fos.index],Status="Extant")

fos.predictions<-data.frame(Genus_Species = ruminant.trdata$phy$tip.label[fos.index],log_brain = ruminant.trdata$dat$brain_mass_g_log_mean[fos.index], log_body_pred = body.predictions[fos.index],log_body=NA,Status="Extinct")
         
merged.data<-rbind(extant.data,fos.predictions)                   

```

## Make Plots
```{r}
brbo.plot<-ggplot(merged.data,aes(y=log_brain))+
geom_point(aes(x=log_body_pred,color=Status),size=2.5,alpha=0.8)+
geom_point(aes(x=log_body),size=2.0,alpha=0.4)+
geom_abline(intercept=mean(posterior.fit.fos.direct$alpha),slope = mean(posterior.fit.fos.direct$beta),lty=2)+
theme_bw()+
theme(legend.position="bottom")+ #5X5
ylab("log Brain Mass (g)")+
  xlab("log Body Mass (g)")

#+theme(legend. position = "none")
brbo.plot+scale_color_aaas()
#Export 5.25X5 PDF

```

## Inverse Regression
Here we will assign one taxa as the fossil species to be predicted, and use Inverse Regression to predict an unknown value based on the combination of phylogeny and allometry. Here we are regression Y - brain size on X body size, and then predicting a fossil Y (brain mass) based on its X (body mass). Finally we mean scale the X data (here body mass) so that the average across species is 0.

```{r}
ruminant.trdata <- make.treedata(phy, neocortex,name_column="species")

ruminant.trdata<-filter(ruminant.trdata,!(is.na(brain_mass_g_log_mean)) & !(is.na(body_mass_g_log_mean)))
ruminant.trdata<-filter(ruminant.trdata,!(is.na(brain_se_squared)) & !(is.na(body_se_squared)))

ruminant.trdata #Full dataset

ruminant.trdata$dat$Status<-"Extant" #Label all species as extant
ruminant.trdata$dat$Status[1]<-"Extinct" #Make one extinct
n.fos<-1

#Inverse Regression - Predicting Y using regression of Y on X
ruminant.trdata$dat$brain_mass_g_log_mean[1]<-0 #Assign this species fake body mass
ruminant.trdata$dat$brain_se_squared[1]<-0 #And ME

ruminant.extant.trdata<-filter(ruminant.trdata, (Status == "Extant")) #Only non-fossil species

#Mean Standardized based on whether fossil is included in dataset
ruminant.trdata$dat$bodycentered<-ruminant.trdata$dat$body_mass_g_log_mean-mean(ruminant.trdata$dat$body_mass_g_log_mean[-n.fos])
ruminant.extant.trdata$dat$bodycentered<-ruminant.extant.trdata$dat$body_mass_g_log_mean-mean(ruminant.extant.trdata$dat$body_mass_g_log_mean)

```
## Rescale Tree
Next, we rescale Tree to Height = 1
```{r}
l.tree<-max(branching.times(ruminant.trdata$phy))
ruminant.trdata$phy$edge.length<-ruminant.trdata$phy$edge.length/l.tree ## rescale tree to height 1
max(branching.times(ruminant.trdata$phy))

l.tree<-max(branching.times(ruminant.extant.trdata$phy))
ruminant.extant.trdata$phy$edge.length<-ruminant.extant.trdata$phy$edge.length/l.tree ## rescale tree to height 1
max(branching.times(ruminant.extant.trdata$phy))

```

## Running Blouch Data Setup Function - 1st trait is adapting to 2
Here we are finally setting up our dataset to run in Blouch, using the blouchOUPredict.setup.v1() function. This function takes out data formatted by treeplyr, and the names of our traits of interest in the order shown. The list produced by this function has data formatted to run both the direct effect (constraint) models and adaptative models. See Grabowski et al. (2016) for more on both of these models.
```{r}

#names.traits<-c("brain_mass_g_log_mean","bodycentered","NA","NA") #With ME
names.traits<-c("brain_mass_g_log_mean","bodycentered","brain_se_squared","body_se_squared") #With ME

#Data must be logged before entry into blouch.setup
#names.traits = c(response, predictor, me.response, me.predictor) - classical = 0 for inverse regression
stan_data<-blouchOUPredict.setup.v1(ruminant.extant.trdata,ruminant.trdata,names.traits,classical=0)

stan_constraint_data<-stan_data[[1]]
stan_adaptive_data<-stan_data[[2]]

```

## Direct EFfect Model for Prediction
Now that we have formatted our data and supplied reasonable priors for the various distributions, we can now run Blouch.

Blouch implements the model of constrained evolution (Hansen & Bartoszek, 2012) known as the direct effect model, previously implemented in Grabowski et al. (2016), which can be used to test for allometric constraints. We will be using this model to predict unknown values as assuming an allometric relationship may be more valid in prediction than an adaptive relationship.

Here we run this model using 2 chains and 4000 iterations per chain. This code follows standard Stan/Rstan code.
```{r}
fit.fos.direct<- rstan::sampling(stanmodels$blouchOUPredict_v1,data = stan_constraint_data,chains = 2,iter = 4000,control=list(adapt_delta=0.95),save_warmup=FALSE)

```
Stan prints out a lot of info, so lets just look at the parameter estimates here and store the most important stuff for later.

```{r}
print(fit.fos.direct,pars = c("a","hl","alpha","beta","r_squared","sigma2_y","RMSE","RMSE_mu","Y_pred_fos_means"))

posterior.fit.fos.direct <- rstan::extract(fit.fos.direct)

```


Blouch follows the same format of parameter estimate presentation as Slouch - see Hansen et al. (2008), Grabowski et al. (2016), and Kopperud et al. (2020) for more explanation.

## Trace and Density Plots for estimated parameters
We can look at how our procedures using the standard trace and density plots from Rstan 

```{r}
par(mfrow = c(1,3))
  
traceplot(fit.fos.direct,c("a","hl","alpha","beta","vy","sigma2_y"))
stan_dens(fit.fos.direct,c("a","hl","alpha","beta","vy","sigma2_y"))
#3 X 8
```

## Inverse Regression Plots
Let's make some plots of our results
```{r}
library(ggsci)
library(ggplot2)
#library(plotly)

```

## Data setup for plots
```{r}
old.par <- par(mar = c(0, 0, 0, 0))
par(old.par)

fos.index<-which(ruminant.trdata$dat$Status=="Extinct")
print(paste("Fossil Species #",fos.index))
extant.index<-which(ruminant.trdata$dat$Status=="Extant")

brain.predictions<-apply(posterior.fit.fos.direct$Y_pred_fos_means,2,mean)
brain.predictions.extant<-apply(posterior.fit.fos.direct$Y_pred_extant_means,2,mean)

extant.data<-data.frame(Genus_Species = ruminant.trdata$phy$tip.label[-fos.index],log_brain = ruminant.trdata$dat$brain_mass_g_log_mean[-fos.index],log_brain_pred = brain.predictions.extant,log_body = ruminant.trdata$dat$bodycentered[-fos.index],Status="Extant")

fos.predictions<-data.frame(Genus_Species = ruminant.trdata$phy$tip.label[fos.index], log_brain= NA, log_brain_pred = brain.predictions[fos.index],log_body=ruminant.trdata$dat$bodycentered[fos.index],Status="Extinct")
         
merged.data<-rbind(extant.data,fos.predictions)                   

```

## Make Plots
```{r}

brbo.plot<-ggplot(merged.data,aes(x=log_body))+
geom_point(aes(y=log_brain),size=2.0,alpha=0.4)+
geom_point(aes(y=log_brain_pred,color=Status),size=2.5,alpha=0.8)+
geom_abline(intercept=mean(posterior.fit.fos.direct$alpha),slope = mean(posterior.fit.fos.direct$beta),lty=2)+
theme_bw()+
theme(legend.position="bottom")+ #5X5
xlab("log Body Mass (g)")+
  ylab("log Brain Mass (g)")

#+theme(legend. position = "none")
brbo.plot+scale_color_aaas()
#Export 5.25X5 PDF

```


