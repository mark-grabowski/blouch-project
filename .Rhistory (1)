geom_density(aes(post.hl.sims,fill="post.hl.sims"),alpha=0.2,data=hl.post)+
scale_fill_manual(name = "Comparison", values = c(hl.sims = "red", hl.post = "green"))
ggplot()+
geom_density(aes(prior.hl.sims,fill="prior.hl.sims"),alpha=0.2,data=hl.sims)+
geom_density(aes(post.hl.sims,fill="post.hl.sims"),alpha=0.2,data=hl.post)+
scale_fill_manual(name = "Comparison", values = c(hl.sims = "red", hl.post = "green"))
ggplot()+
geom_density(aes(prior.hl.sims,fill="prior.hl.sims"),alpha=0.2,data=hl.sims)+
geom_density(aes(post.hl.sims,fill="post.hl.sims"),alpha=0.2,data=hl.post)
library(ggplot2)
library(ggsci)
ggplot()+
geom_density(aes(prior.hl.sims,fill="prior.hl.sims"),alpha=0.2,data=hl.sims)+
geom_density(aes(post.hl.sims,fill="post.hl.sims"),alpha=0.2,data=hl.post)+
scale_fill_npg()
ggplot()+
geom_density(aes(prior.hl.sims,fill="prior.hl.sims"),alpha=0.2,data=hl.sims)+
geom_density(aes(post.hl.sims,fill="post.hl.sims"),alpha=0.2,data=hl.post)+
theme_bw()
ggplot()+
geom_density(aes(prior.hl.sims,fill="prior.hl.sims"),alpha=0.2,data=hl.sims)+
geom_density(aes(post.hl.sims,fill="post.hl.sims"),alpha=0.2,data=hl.post)+
theme_bw()+
labs(title="Density Curves",x="Half-life", y = "Density")
ggplot()+
geom_density(aes(prior.hl.sims,fill="prior.hl.sims"),alpha=0.2,data=hl.sims)+
geom_density(aes(post.hl.sims,fill="post.hl.sims"),alpha=0.2,data=hl.post)+
theme_bw()+
labs(title="Density Curves",x="Half-life", y = "Density")+
scale_fill_npg()
ggplot()+
geom_density(aes(prior.hl.sims,fill="prior.hl.sims"),alpha=0.2,data=hl.sims)+
geom_density(aes(post.hl.sims,fill="post.hl.sims"),alpha=0.2,data=hl.post)+
theme_bw()+
labs(title="Density Curves",x="Half-life", y = "Density")+
scale_fill_manual(labels=c("Posterior","Prior"))+
scale_fill_npg()
ggplot()+
geom_density(aes(prior.hl.sims,fill="prior.hl.sims"),alpha=0.2,data=hl.sims)+
geom_density(aes(post.hl.sims,fill="post.hl.sims"),alpha=0.2,data=hl.post)+
theme_bw()+
labs(title="Density Curves",x="Half-life", y = "Density")+
#scale_fill_manual(labels=c("Posterior","Prior"))+
scale_fill_npg(labels=c("Posterior","Prior"))
ggplot()+
geom_density(aes(prior.hl.sims,fill="prior.hl.sims"),alpha=0.2,data=hl.sims)+
geom_density(aes(post.hl.sims,fill="post.hl.sims"),alpha=0.2,data=hl.post)+
theme_bw()+
labs(title="Density Curves",x="Half-life", y = "Density")+
#scale_fill_manual(labels=c("Posterior","Prior"))+
scale_fill_npg(name="Comparison",labels=c("Posterior","Prior"))
ggplot()+
geom_density(aes(prior.hl.sims,fill="prior.hl.sims"),alpha=0.2,data=hl.sims)+
geom_density(aes(post.hl.sims,fill="post.hl.sims"),alpha=0.2,data=hl.post)+
theme_bw()+
labs(title="Prior vs. Posterior Distribution ",x="Half-life", y = "Density")+
#scale_fill_manual(labels=c("Posterior","Prior"))+
scale_fill_npg(name="",labels=c("Posterior","Prior"))
sigma2y.sims<-rexp(n=1000,rate=5)
sigma2y.sims<-data.frame(sigma2y.sims)
names(sigma2y.sims)<-"prior.sigma2y.sims"
sigma2y.post<-data.frame(post$sigma2_y)
names(sigma2y.post)<-"post.sigma2y.sims"
ggplot()+
geom_density(aes(prior.sigma2y.sims,fill="prior.sigma2y.sims"),alpha=0.2,data=sigma2y.sims)+
geom_density(aes(post.sigma2y.sims,fill="post.sigma2y.sims"),alpha=0.2,data=sigma2y.post)+
theme_bw()+
labs(title="Prior vs. Posterior Distribution ",x="Sigma2_y", y = "Density")+
#scale_fill_manual(labels=c("Posterior","Prior"))+
scale_fill_npg(name="",labels=c("Posterior","Prior"))
rm(list=ls())
calc_direct_V<-function(phy, sigma2_y, a){ #Calculate V matrix for direct effect and regime-only models
ts<-ts_fxn(phy)
ta<-ts[[1]]
tij<-ts[[2]] #Same as Cophenetic Distance matrix
Vt<-sigma2_y /( 2 * a) * ((1 - exp(-2 * a * ta)) * exp(-a * tij)) #ta - time from root to tips, tij  - total time separating spcies
return(Vt)
}
ts_fxn<-function(phy){ #Calculate t
n<-length(phy$tip.label)
mrca1 <- ape::mrca(phy) #Node numbers for MRCA of tips
times <- ape::node.depth.edgelength(phy) #Time from root to tips of each node, starting with the tips
ta <- matrix(times[mrca1], nrow=n, dimnames = list(phy$tip.label, phy$tip.label)) #Matrix with time from root to MRCA of pairs of tips - pulls out values of times that correspond with node numbers - integers
T.term <- times[1:n] #Times from root for tips
tia <- times[1:n] - ta #Times from root to tips - times from root to MRCA = times from MRCA to tips
tja <- t(tia) #Transpose of the times from MRCA to tips matrix
#tij <- tja + tia #Sum of matrix and its transpose - total time separating species
tij<-cophenetic(phy)
#return(list(ta,tia,tja,tij,T.term))
return(list(ta,tij,T.term,tja))
}
#############################################################################################
#Data formatting drawn from Slouch
parent <- function(phy, x){ #Returns parent node of offspring node given node number
m <- which(phy$edge[, 2] == x)
return(phy$edge[m, 1])
}
lineage.nodes <- function(phy, x){ #Given a certain node, return the list of all parent nodes back to the root of the tree
k <- x #Save x in k
N <- length(phy$tip.label) #total number of tips on tree
while(x != N + 1){ #while node is not equal to number of tips +1  - starting node - 51 here
k <- c(k, parent(phy, x)) #Return node at beginning of edge
x <- tail(k, n = 1) #x is assigned value at end of k, so end of the list of beginning nodes
#50->99->89->51 0- tracing lineage back by nodes
}
return(k)
}
lineage.constructor <- function(phy, e, anc_maps="regimes", regimes, ace){ #Revised 2022 Slouch version
#e = 50 - tip
#regimes[50]<-"OU2"
nodes <- lineage.nodes(phy, e) #Given a certain node, return the list of all parent nodes back to the root of the tree
#[1] 50 99 87 51
min_age <- min(ape::node.depth.edgelength(phy)[nodes]) #min root to node time
#[1] 1.0000000 0.4794736 0.1406307 0.0000000
if(anc_maps == "regimes"){
lineage_regimes <- rev(regimes[nodes]) #Reverse order of regimes from that in nodes object
#[1] OU1 OU1 OU1 OU2
#Levels: OU1 OU2
which.regimes <- lapply(levels(regimes), function(x) {res <- match(regimes[nodes], x); res[is.na(res)] <- 0; return(res) })
#Determine which regimes each node is in
#x is the levels of the regimes, match takes the regimes at the nodes in the lineage and determines whether which level of regime the node belongs to
#Any NAs get 0 - this happens when regimes are not assigned on a lineage
#[[1]]
#[1] 0 1 1 1 - Tip is OU2, so gets 0 for OU1 here but 1 for OU2 below - reverse order
#[[2]]
#[1] 1 0 0 0
times <-  ape::node.depth.edgelength(phy)[nodes] #Root to node time
#[1] 1.0000000 0.4794736 0.1406307 0.0000000
timeflip <- times[1] - times ## Time from tips to node(s)
#[1] 0.0000000 0.5205264 0.8593693 1.0000000
}else if(anc_maps == "simmap"){
## Simmap splits up each edge into sub-edges, depending on the split. So, we use edges instead of nodes, and introduce sub-edges
edge_is <- which(phy$edge[,2] %in% nodes)
subedges <- unlist(lapply(edge_is, function(i) phy$maps[[i]]))
simmap_regimes <- rev(names(subedges))
which.regimes <- lapply(levels(regimes), function(x) {res <- match(simmap_regimes, x); res[is.na(res)] <- 0; return(res)})
# Problem. simmap does not provide root estimate. Assuming root estimate is equal to the oldest branch estimate
root <- lapply(which.regimes, function(e) tail(e, n= 1))
which.regimes <- lapply(seq_along(levels(regimes)), function(x) c(which.regimes[[x]], root[[x]]))
timeflip <- cumsum(c(min_age, unname(subedges)))
times <- rev(timeflip)
# save the regimes in this lineage
lineage_regimes <- names(subedges)
}
#stop()
names(which.regimes) <- levels(regimes)
#$OU1
#[1] 1 1 1 1
#$OU2
#[1] 0 0 0 0
t_end <- tail(timeflip, n = -1) #Remove first element - tip value
#[1] 0.0000000 0.5205264 0.8593693 1.0000000 - original
#[1] 0.5205264 0.8593693 1.0000000 -
t_beginning <- head(timeflip, n = -1) #Remove last element - root value
#[1] 0.0000000 0.5205264 0.8593693
regime_time <- c(t_end - t_beginning, min_age) #Calculate time within a regime?
#Sum(time at end of linege - time at beginning of lineage)
#[1] 0.5205264 0.3388429 0.1406307 0.0000000
return(list(nodes = nodes,
times = times,
t_end = t_end,
t_beginning = t_beginning,
regime_time = regime_time,
which.regimes = which.regimes,
lineage_regimes = lineage_regimes))
}
weights_segments <- function(a, lineage){#For individual lineage, determine the weighting of each segment
#t_beginning and t_end are both vectors, and subtracting them from each other lines up the beginning and end of one segment
#because if tge tail/head procedure above
res <- c(exp(-a * lineage$t_beginning) - exp(-a * lineage$t_end),
exp(-a * lineage$times[1]))
return(res)
}
weights_regimes <- function(a, lineage) {#For individual lineage, sum up the segments in each regimes
#nt <- lineage$nodes_time
res <- weights_segments(a, lineage) ## Rcpp wrapper, equivalent to above commented out code
w <- vapply(lineage$which.regimes, function(e) sum(e*res), FUN.VALUE = 0) ## Sum coefficients for which the respective regime is equal
return(w) #Return named vector with regimes weights for individual lineage
}
weight.matrix <- function(phy, a, lineages){ #Wrapper to apply weights_regimes to each lineage
res <- t(vapply(lineages, function(x) weights_regimes(a, x),
FUN.VALUE = numeric(length(lineages[[1]]$which.regimes))) ## Specify type of output
)
rownames(res) <- phy$tip.label
return(res)
}
## Thanks to user "snaut" at stackoverflow, http://stackoverflow.com/users/1999873/snaut
concat.factor <- function(...){
as.factor(do.call(c, lapply(list(...), as.character)))
}
#Script to simulate data to test Blouch OU regimes model
library(devtools)
library(ape)
library(slouch)
library(rstan)
library(treeplyr)
library(ggplot2)
library(ggsci)
library(MASS)
########################################################################################################
#Basic Setup
#Vt = sigma2_y /( 2 * a) * ((1 - exp(-2 * a * ta)) .* exp(-a * tij)); //From Hansen (1997) Original Stan
set.seed(1)
#tree.10K<-read.tree("/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch project/Original Submission/Blouch Testing/Phylogeny/10KPrimateTree.tre")
tree.10K<-read.tree("/Users/markgrabowski/Library/CloudStorage/GoogleDrive-mark.walter.grabowski@gmail.com/Other computers/My MacBook Pro/Documents/Academic/Research/Current Projects/Blouch project/Original Submission/Blouch Testing/Phylogeny/10KPrimateTree.tre")
N<-50 #Number of species
#set.seed(1) #Set seed to get same random species each time
phy <- keep.tip(tree.10K,sample(tree.10K$tip.label)[1:N])
phy<-multi2di(phy)
l.tree<-max(branching.times(phy)) ## rescale tree to height 1
phy$edge.length<-phy$edge.length/l.tree
#Set regimes - manually - 2 regimes
#Locate nodes
plot(phy,no.margin=TRUE,edge.width=2,cex=0.7)
nodelabels(frame="none",adj=c(1.1,-0.4))
tiplabels()
#Using node 54
#Paint Regimes on Tree
#source("/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Simulation Code/Functions/set.converge.regimes.R") #Macbook Pro
source("/Users/markgrabowski/Library/CloudStorage/GoogleDrive-mark.walter.grabowski@gmail.com/Other computers/My MacBook Pro/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Simulation Code/Functions/set.converge.regimes.R") #Mac Studio
shifts<-c(54) #Location of nodes with regime shifts
trdata<-data.frame(phy$tip.label)
trdata<-make.treedata(phy,trdata)
trdata<-set.converge.regimes(trdata,shifts)
#Check if manual setting code worked
shifts.total<-c(trdata$dat$regimes,trdata$phy$node.label)
edge.regimes <- factor(shifts.total[trdata$phy$edge[,2]])
print(edge.regimes)
#Get ggplot colors used for plot to make on tree
gg_color_hue <- function(n) {
hues = seq(15, 375, length=n+1)
hcl(h=hues, l=65, c=100)[1:n]
}
reg.colors<-gg_color_hue(length(unique(trdata$dat$regimes)))
print(reg.colors)
plot(trdata$phy,edge.color = reg.colors[edge.regimes], edge.width = 1, cex = 0.2)
############################################################################
#Simulate data
n<-length(trdata$phy$tip.label)
mrca1 <- ape::mrca(trdata$phy)
times <- ape::node.depth.edgelength(trdata$phy)
ta <- matrix(times[mrca1], nrow=n, dimnames = list(trdata$phy$tip.label, trdata$phy$tip.label))
T.term <- times[1:n]
tia <- times[1:n] - ta
tja <- t(tia)
tij <- tja + tia
regimes_internal <-trdata$phy$node.label
regimes_tip <- trdata$dat$regimes
regimes <- concat.factor(regimes_tip, regimes_internal)
anc_maps<-"regimes"
lineages <- lapply(1:n, function(e) lineage.constructor(trdata$phy, e, anc_maps, regimes, ace)) #Trace lineage from tips (n) to root and determine regimes of each node or branch
#Simulate Y based on V and incorporating regimes
#Setup parameters
hl<-0.1
a<-log(2)/hl
sigma2_y<-0.1
#alpha<-4 #Intecept
optima<-c(0.35,0.25) #Intercepts for two regimes
dmX<-weight.matrix(trdata$phy, a, lineages) #Slouch approach
mu<-dmX%*%optima #Simulate mu for Y
V<-calc_direct_V(phy, sigma2_y, a)
Y<-mvrnorm(n=1,mu,V)
nodes<-NULL
store<-NULL
reg_num_lineage<-NULL
for(i in 1:length(lineages)){
store<-c(store,length(lineage.nodes(trdata$phy,i))) #Calculate max node height
reg_num_lineage<-c(reg_num_lineage,length(unique(lineages[[i]]$lineage_regimes)))
nodes<-c(nodes,length(lineages[[i]]$nodes))
}
max_node_num<-max(store)
times<-matrix(0,length(lineages),max_node_num)
t_end<-matrix(0,length(lineages),max_node_num)
t_beginning<-matrix(0,length(lineages),max_node_num)
reg_match<-data.frame(matrix(0,length(lineages),max_node_num))
for(i in 1:length(lineages)){
times[i,1:length(lineages[[i]]$times)]<-lineages[[i]]$times
t_end[i,1:length(lineages[[i]]$t_end)]<-lineages[[i]]$t_end
t_beginning[i,1:length(lineages[[i]]$t_beginning)]<-lineages[[i]]$t_beginning
reg_match[i,1:length(lineages[[i]]$lineage_regimes)]<-rev(as.numeric(lineages[[i]]$lineage_regimes))
}
dat<-list(N=N,n_reg=length(unique(regimes)),max_node_num=max_node_num,Y_obs=Y,ta=ta,tij=tij,t_beginning=t_beginning,t_end=t_end,times=times,reg_match=reg_match,nodes=nodes)
hl.sims<-rlnorm(n=1000,meanlog=log(0.4),sdlog=0.75)
plot(density(hl.sims),main="Half-life prior distribution")
abline(v=c(0.1,1))
quantile(hl.sims,probs=c(0.1,0.25,0.5,0.75,0.9))
hl.sims[hl.sims<0.1]
hl.sims[hl.sims>1]
#Milestone 4
#Regime model
#setwd("/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Stan Models Milestones/Testing Versions/")
#stanc("/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Stan Models Milestones/Testing Versions/blouchOU_reg.stan")
setwd("/Users/markgrabowski/Library/CloudStorage/GoogleDrive-mark.walter.grabowski@gmail.com/Other computers/My MacBook Pro/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Stan Models Milestones/Testing Versions/")
stanc("/Users/markgrabowski/Library/CloudStorage/GoogleDrive-mark.walter.grabowski@gmail.com/Other computers/My MacBook Pro/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Stan Models Milestones/Testing Versions/blouchOU_reg.stan")
stan_model <- stan_model("blouchOU_reg.stan")
fit.npi.regimes<- rstan::sampling(object = stan_model,data = dat,chains = 2,iter =4000)
#,control=list(adapt_delta=0.80))
print(fit.npi.regimes,pars = c("hl","vy","optima","sigma2_y"))
post<-extract(fit.npi.regimes)
hl.sims<-rlnorm(n=1000,meanlog=log(0.4),sdlog=0.75)
hl.sims<-data.frame(hl.sims)
names(hl.sims)<-"prior.hl.sims"
hl.post<-data.frame(post$hl)
names(hl.post)<-"post.hl.sims"
ggplot()+
geom_density(aes(prior.hl.sims,fill="prior.hl.sims"),alpha=0.2,data=hl.sims)+
geom_density(aes(post.hl.sims,fill="post.hl.sims"),alpha=0.2,data=hl.post)+
theme_bw()+
labs(title="Prior vs. Posterior Distribution ",x="Half-life", y = "Density")+
#scale_fill_manual(labels=c("Posterior","Prior"))+
scale_fill_npg(name="",labels=c("Posterior","Prior"))
sigma2_y<-rexp(n=1000,rate=5)
plot(density(sigma2_y),main="Sigma2_y prior distribution")
quantile(sigma2_y,probs=c(0.1,0.5,0.75,0.9))
sigma2_y[sigma2_y<0.1]
sigma2_y[sigma2_y>1]
sigma2y.sims<-rexp(n=1000,rate=5)
sigma2y.sims<-data.frame(sigma2y.sims)
names(sigma2y.sims)<-"prior.sigma2y.sims"
sigma2y.post<-data.frame(post$sigma2_y)
names(sigma2y.post)<-"post.sigma2y.sims"
ggplot()+
geom_density(aes(prior.sigma2y.sims,fill="prior.sigma2y.sims"),alpha=0.2,data=sigma2y.sims)+
geom_density(aes(post.sigma2y.sims,fill="post.sigma2y.sims"),alpha=0.2,data=sigma2y.post)+
theme_bw()+
labs(title="Prior vs. Posterior Distribution ",x="Sigma2_y", y = "Density")+
#scale_fill_manual(labels=c("Posterior","Prior"))+
scale_fill_npg(name="",labels=c("Posterior","Prior"))
optima.sims<-rnorm(n=1000,0,0.5)
optima.sims<-data.frame(optima.sims)
optima1.post<-data.frame(post$optima[1])
optima1.post
post$optima
post$optima[,1]
optima.post<-data.frame(post$optima)
optima.sims<-rnorm(n=1000,0,0.5)
optima.sims<-data.frame(optima.sims)
names(optima.sims)<-"prior.optima.sims"
optima.post<-data.frame(post$optima)
names(optima.post)<-c("post.optima.1","post.optima.2")
ggplot()+
geom_density(aes(prior.optima.sims,fill="prior.optima.sims"),alpha=0.2,data=sigma2y.sims)+
geom_density(aes(post.optima.1,fill="post.optima.1"),alpha=0.2,data=optima.post)+
geom_density(aes(post.optima.2,fill="post.optima.2"),alpha=0.2,data=optima.post)+
theme_bw()+
labs(title="Prior vs. Posterior Distribution ",x="Optima", y = "Density")+
#scale_fill_manual(labels=c("Posterior","Prior"))+
scale_fill_npg(name="",labels=c("Posterior Optima 1","Posterior Optima 2","Prior"))
optima.sims<-rnorm(n=1000,0,0.5)
optima.sims<-data.frame(optima.sims)
names(optima.sims)<-"prior.optima.sims"
optima.post<-data.frame(post$optima)
names(optima.post)<-c("post.optima.1","post.optima.2")
ggplot()+
geom_density(aes(prior.optima.sims,fill="prior.optima.sims"),alpha=0.2,data=sigma2y.sims)+
geom_density(aes(post.optima.1,fill="post.optima.1"),alpha=0.2,data=optima.post)+
geom_density(aes(post.optima.2,fill="post.optima.2"),alpha=0.2,data=optima.post)+
theme_bw()+
labs(title="Prior vs. Posterior Distribution ",x="Optima", y = "Density")+
#scale_fill_manual(labels=c("Posterior","Prior"))+
scale_fill_npg(name="",labels=c("Posterior Optima 1","Posterior Optima 2","Prior"))
ggplot()+
geom_density(aes(prior.optima.sims,fill="prior.optima.sims"),alpha=0.2,data=optima.sims)+
geom_density(aes(post.optima.1,fill="post.optima.1"),alpha=0.2,data=optima.post)+
geom_density(aes(post.optima.2,fill="post.optima.2"),alpha=0.2,data=optima.post)+
theme_bw()+
labs(title="Prior vs. Posterior Distribution ",x="Optima", y = "Density")+
#scale_fill_manual(labels=c("Posterior","Prior"))+
scale_fill_npg(name="",labels=c("Posterior Optima 1","Posterior Optima 2","Prior"))
#Milestone 4
#Regime model
#setwd("/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Stan Models Milestones/Testing Versions/")
#stanc("/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Stan Models Milestones/Testing Versions/blouchOU_reg.stan")
setwd("/Users/markgrabowski/Library/CloudStorage/GoogleDrive-mark.walter.grabowski@gmail.com/Other computers/My MacBook Pro/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Stan Models Milestones/Testing Versions/")
stanc("/Users/markgrabowski/Library/CloudStorage/GoogleDrive-mark.walter.grabowski@gmail.com/Other computers/My MacBook Pro/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Stan Models Milestones/Testing Versions/blouchOU_reg.stan")
stan_model <- stan_model("blouchOU_reg.stan")
fit.npi.regimes<- rstan::sampling(object = stan_model,data = dat,chains = 2,iter =4000)
#,control=list(adapt_delta=0.80))
print(fit.npi.regimes,pars = c("hl","vy","optima","sigma2_y"))
post<-extract(fit.npi.regimes)
#Milestone 4
#Regime model
#setwd("/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Stan Models Milestones/Testing Versions/")
#stanc("/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Stan Models Milestones/Testing Versions/blouchOU_reg.stan")
setwd("/Users/markgrabowski/Library/CloudStorage/GoogleDrive-mark.walter.grabowski@gmail.com/Other computers/My MacBook Pro/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Stan Models Milestones/Testing Versions/")
stanc("/Users/markgrabowski/Library/CloudStorage/GoogleDrive-mark.walter.grabowski@gmail.com/Other computers/My MacBook Pro/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Stan Models Milestones/Testing Versions/blouchOU_reg.stan")
stan_model <- stan_model("blouchOU_reg.stan")
fit.npi.regimes<- rstan::sampling(object = stan_model,data = dat,chains = 2,iter =4000)
#,control=list(adapt_delta=0.80))
print(fit.npi.regimes,pars = c("hl","vy","optima","sigma2_y"))
post<-extract(fit.npi.regimes)
setwd("/Users/markgrabowski/Library/CloudStorage/GoogleDrive-mark.walter.grabowski@gmail.com/Other computers/My MacBook Pro/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Stan Models Milestones/Testing Versions/")
stanc("/Users/markgrabowski/Library/CloudStorage/GoogleDrive-mark.walter.grabowski@gmail.com/Other computers/My MacBook Pro/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Stan Models Milestones/Testing Versions/blouchOU_reg.stan")
stan_model <- stan_model("blouchOU_reg.stan")
fit.npi.regimes<- rstan::sampling(object = stan_model,data = dat,chains = 2,iter =4000)
#,control=list(adapt_delta=0.80))
print(fit.npi.regimes,pars = c("hl","vy","optima","sigma2_y"))
post<-extract(fit.npi.regimes)
optima.sims<-rnorm(n=1000,0,1)
optima.sims<-data.frame(optima.sims)
names(optima.sims)<-"prior.optima.sims"
optima.post<-data.frame(post$optima)
names(optima.post)<-c("post.optima.1","post.optima.2")
ggplot()+
geom_density(aes(prior.optima.sims,fill="prior.optima.sims"),alpha=0.2,data=optima.sims)+
geom_density(aes(post.optima.1,fill="post.optima.1"),alpha=0.2,data=optima.post)+
geom_density(aes(post.optima.2,fill="post.optima.2"),alpha=0.2,data=optima.post)+
theme_bw()+
labs(title="Prior vs. Posterior Distribution ",x="Optima", y = "Density")+
#scale_fill_manual(labels=c("Posterior","Prior"))+
scale_fill_npg(name="",labels=c("Posterior Optima 1","Posterior Optima 2","Prior"))
setwd("/Users/markgrabowski/Library/CloudStorage/GoogleDrive-mark.walter.grabowski@gmail.com/Other computers/My MacBook Pro/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Stan Models Milestones/Testing Versions/")
stanc("/Users/markgrabowski/Library/CloudStorage/GoogleDrive-mark.walter.grabowski@gmail.com/Other computers/My MacBook Pro/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Stan Models Milestones/Testing Versions/blouchOU_reg.stan")
stan_model <- stan_model("blouchOU_reg.stan")
fit.npi.regimes<- rstan::sampling(object = stan_model,data = dat,chains = 2,iter =2000)
#,control=list(adapt_delta=0.80))
print(fit.npi.regimes,pars = c("hl","vy","optima","sigma2_y"))
post<-extract(fit.npi.regimes)
#Slouch testing
slouch.results<-slouch.fit(phy = trdata$phy,
species = trdata$phy$tip.label,
response = dat$Y_obs,
fixed.fact = trdata$dat$regimes)
summary(slouch.results)
set.seed(1)
#tree.10K<-read.tree("/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch project/Original Submission/Blouch Testing/Phylogeny/10KPrimateTree.tre")
tree.10K<-read.tree("/Users/markgrabowski/Library/CloudStorage/GoogleDrive-mark.walter.grabowski@gmail.com/Other computers/My MacBook Pro/Documents/Academic/Research/Current Projects/Blouch project/Original Submission/Blouch Testing/Phylogeny/10KPrimateTree.tre")
N<-100 #Number of species
phy <- keep.tip(tree.10K,sample(tree.10K$tip.label)[1:N])
phy<-multi2di(phy)
l.tree<-max(branching.times(phy)) ## rescale tree to height 1
phy$edge.length<-phy$edge.length/l.tree
#Set regimes - manually - 2 regimes
#Locate nodes
plot(phy,no.margin=TRUE,edge.width=2,cex=0.7)
nodelabels(frame="none",adj=c(1.1,-0.4))
tiplabels()
#Paint Regimes on Tree
#source("/Users/markgrabowski/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Simulation Code/Functions/set.converge.regimes.R") #Macbook Pro
source("/Users/markgrabowski/Library/CloudStorage/GoogleDrive-mark.walter.grabowski@gmail.com/Other computers/My MacBook Pro/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Simulation Code/Functions/set.converge.regimes.R") #Mac Studio
shifts<-c(169) #Location of nodes with regime shifts
trdata<-data.frame(phy$tip.label)
trdata<-make.treedata(phy,trdata)
trdata<-set.converge.regimes(trdata,shifts)
#Check if manual setting code worked
shifts.total<-c(trdata$dat$regimes,trdata$phy$node.label)
edge.regimes <- factor(shifts.total[trdata$phy$edge[,2]])
print(edge.regimes)
#Get ggplot colors used for plot to make on tree
gg_color_hue <- function(n) {
hues = seq(15, 375, length=n+1)
hcl(h=hues, l=65, c=100)[1:n]
}
reg.colors<-gg_color_hue(length(unique(trdata$dat$regimes)))
print(reg.colors)
plot(trdata$phy,edge.color = reg.colors[edge.regimes], edge.width = 1, cex = 0.2)
############################################################################
#Simulate data
n<-length(trdata$phy$tip.label)
mrca1 <- ape::mrca(trdata$phy)
times <- ape::node.depth.edgelength(trdata$phy)
ta <- matrix(times[mrca1], nrow=n, dimnames = list(trdata$phy$tip.label, trdata$phy$tip.label))
T.term <- times[1:n]
tia <- times[1:n] - ta
tja <- t(tia)
tij <- tja + tia
regimes_internal <-trdata$phy$node.label
regimes_tip <- trdata$dat$regimes
regimes <- concat.factor(regimes_tip, regimes_internal)
anc_maps<-"regimes"
lineages <- lapply(1:n, function(e) lineage.constructor(trdata$phy, e, anc_maps, regimes, ace)) #Trace lineage from tips (n) to root and determine regimes of each node or branch
hl<-0.1
a<-log(2)/hl
sigma2_y<-0.1
#alpha<-4 #Intecept
optima<-c(0.35,0.25) #Intercepts for two regimes
dmX<-weight.matrix(trdata$phy, a, lineages) #Slouch approach
mu<-dmX%*%optima #Simulate mu for Y
V<-calc_direct_V(phy, sigma2_y, a)
Y<-mvrnorm(n=1,mu,V)
nodes<-NULL
store<-NULL
reg_num_lineage<-NULL
for(i in 1:length(lineages)){
store<-c(store,length(lineage.nodes(trdata$phy,i))) #Calculate max node height
reg_num_lineage<-c(reg_num_lineage,length(unique(lineages[[i]]$lineage_regimes)))
nodes<-c(nodes,length(lineages[[i]]$nodes))
}
max_node_num<-max(store)
times<-matrix(0,length(lineages),max_node_num)
t_end<-matrix(0,length(lineages),max_node_num)
t_beginning<-matrix(0,length(lineages),max_node_num)
reg_match<-data.frame(matrix(0,length(lineages),max_node_num))
for(i in 1:length(lineages)){
times[i,1:length(lineages[[i]]$times)]<-lineages[[i]]$times
t_end[i,1:length(lineages[[i]]$t_end)]<-lineages[[i]]$t_end
t_beginning[i,1:length(lineages[[i]]$t_beginning)]<-lineages[[i]]$t_beginning
reg_match[i,1:length(lineages[[i]]$lineage_regimes)]<-rev(as.numeric(lineages[[i]]$lineage_regimes))
}
dat<-list(N=N,n_reg=length(unique(regimes)),max_node_num=max_node_num,Y_obs=Y,ta=ta,tij=tij,t_beginning=t_beginning,t_end=t_end,times=times,reg_match=reg_match,nodes=nodes)
setwd("/Users/markgrabowski/Library/CloudStorage/GoogleDrive-mark.walter.grabowski@gmail.com/Other computers/My MacBook Pro/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Stan Models Milestones/Testing Versions/")
stanc("/Users/markgrabowski/Library/CloudStorage/GoogleDrive-mark.walter.grabowski@gmail.com/Other computers/My MacBook Pro/Documents/Academic/Research/Current Projects/Blouch project/R1 blouch-testing branch/Stan Models Milestones/Testing Versions/blouchOU_reg.stan")
stan_model <- stan_model("blouchOU_reg.stan")
fit.npi.regimes<- rstan::sampling(object = stan_model,data = dat,chains = 2,iter =2000)
fit.npi.regimes<- rstan::sampling(object = stan_model,data = dat,chains = 1,iter =2000)
#,control=list(adapt_delta=0.80))
print(fit.npi.regimes,pars = c("hl","vy","optima","sigma2_y"))
post<-extract(fit.npi.regimes)
fit.npi.regimes<- rstan::sampling(object = stan_model,data = dat,chains = 1,iter =2000)
#,control=list(adapt_delta=0.80))
print(fit.npi.regimes,pars = c("hl","vy","optima","sigma2_y"))
post<-extract(fit.npi.regimes)
